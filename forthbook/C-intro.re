= FORTH 序論

この章では、FORTH の学習を始める上で把握しておくべき周辺の基礎概念と、
FORTH の中核をなす諸概念について扱っていく。

== ワードとインタプリタ

FORTH のシンタックスはおそらく他のほとんどのプログラミング言語よりも単純だ。
要は「文字列を空白文字で区切って並べただけ」だ。
拍子抜けされるかもしれないが、この極限まで単純化されたシンタックスが、
後述する多彩な意味論と相まって、高い融通性を発揮する。

これから少しの間、Gforth を「電卓」として使っていく。
Gforth を起動し、@<list>{arith}を書き写してみよう。
入力が終わったら、改行してみてほしい。

//list[arith][はじめての FORTH プログラム][forth]{
6 3 4 + *
//}

正しく動いていれば、
たった今書き込んだコードのすぐ左に @<code>{ok 1} と表示されたはずだ。
これは、Gforth が入力されたコードをすべて解釈実行し終わったことを示している。
Gforth は、この瞬間にどんな流れで、どう@<list>{arith}を解釈したのだろうか。

Gforth は手続きに必要なパラメータをスタック上で管理しながら、
ソースコードを先頭から一直線に解釈する。@<list>{arith}を構成している文字列は
@<code>{6}, @<code>{3}, @<code>{4}, @<code>{+}, @<code>{*} の5つだ。

 * 最初の3つは32ビット符号付き整数値として解釈され、それぞれ順番にスタックにプッシュされる。

 * あと2つの、数値として認識できない文字列は「@<strong>{ワード}(word)」として解釈される。

ワードは、簡単に言えば手続きに名前をつけたものだ。
これは、他の言語における関数やサブルーチンのようなものとして理解される。

FORTH 処理系がインタプリタとして動作しているときにワードを認識すると、
対応する「解釈時意味論(interpretation semantics)」に従って呼び出しが発生する。
後述するが、「～時意味論」のようにワードには複数の意味論が存在し、
呼び出し時の処理系の状態によって、ワードの挙動は異なる(ように作為的にワードを定義できる)。

FORTH 処理系はデフォルトではインタプリタとして動作しており、
この段階では解釈時意味論だけ考慮していれば問題ない。

@<list>{arith}の説明に戻るが、インタプリタの挙動は以下のようになる。

 1. @<code>{6 3 4} まで解釈した直後には、スタックにはそのまま底から @<code>{6}, @<code>{3}, @<code>{4} が積まれている。
 2. @<code>{+} を読み込んだインタプリタは、ワード名とその定義を紐付けて保存している「辞書(dictionary)@<fn>{dictionary}」からその定義を見つけ出し、呼び出す。@<code>{+} ワードはスタックの一番上に積まれている2つの数 @<code>{3}, @<code>{4} をポップし、和 @<code>{7} をプッシュする。
 3. @<code>{*} を読み込んだインタプリタは同様に定義を見つけ出して呼び出す。@<code>{*} ワードはスタックの一番上に積まれている2つの数 @<code>{6}, @<code>{7} をポップし、積 @<code>{42} をプッシュする。

//footnote[dictionary][辞書は、実際には「ワードの定義が書き込まれたメモリ領域の先頭番地」を保存していくものだ。]

つまり、@<list>{arith} は @<m>{(3 + 4) × 6} を評価させて結果をスタックに積むプログラムだったわけだ。
それを確かめるために、今のスタックの内容を出力させる @<code>{.S} ワードを呼び出してみてほしい。
すぐ右側に @<code>{ <1> 42 ok 1} と出力されるはずだ。
評価結果が正しく格納されていることがわかる。

このように、FORTH において算術式の評価を表現すると、自然に「被演算子を先に並べて、最後に演算子を書く記法」になる。
この記法は一般的には「逆ポーランド記法」と呼ばれており、スタックとの相性が良い。

== スタック操作ワード

FORTH にはスタックの内容を操作するための組み込みワードが用意されている。

その1つが @<code>{DUP} ワードだ。スタックの一番上に積まれている要素を複製する。

== まとめ

== 練習問題

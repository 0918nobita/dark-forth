= FORTH 序論

この章では、FORTH の学習を始める上で把握しておくべき周辺の基礎概念と、
FORTH の中核をなす諸概念について扱っていく。

== ワードとインタプリタ

FORTH のシンタックスは、要は「文字列を空白文字で区切って並べただけ」だ。
この極限まで単純化されたシンタックスが、
後述する多彩な意味論と相まって、高い融通性を発揮する。

これから少しの間、Gforth を「電卓」として使っていく。
Gforth を起動し、@<list>{arith}を書き写してみよう。
入力が終わったら、改行してみてほしい。

//list[arith][はじめての FORTH プログラム][forth]{
6 3 4 + *　.
//}

正しく動いていれば、
たった今書き込んだコードのすぐ左に @<code>{42 ok 0} と表示されたはずだ。
これは、Gforth が入力されたコードをすべて解釈実行し終わったことを示している。
Gforth は、この瞬間にどんな流れで、どう@<list>{arith}を解釈したのだろうか。

#@# textlint-disable ja-technical-writing/max-comma
Gforth は手続きに必要なパラメータをスタック上で管理しながら、
ソースコードを先頭から一直線に解釈する。@<list>{arith}を構成している文字列は
@<code>{6}, @<code>{3}, @<code>{4}, @<code>{+}, @<code>{*}, @<code>{.} の 6 つだ。
#@# textlint-enable ja-technical-writing/max-comma

 * 最初の 3 つは 32 ビット符号付き整数値として解釈され、それぞれ順番にスタックにプッシュされる。

 * あと 3 つの、数値として認識できない文字列は「@<b>{ワード}(word)」として解釈される。

ワードは、簡単に言えば手続きに名前をつけたものだ。
これは、他の言語における関数やサブルーチンのようなものとして理解される。

FORTH 処理系がインタプリタとして動作しているときにワードを認識すると、
対応する@<hidx>{解釈時意味論}@<b>{解釈時意味論}(interpretation semantics)に従って呼び出しが発生する。
後述するが、「～時意味論」のようにワードには複数の意味論が存在し、
呼び出し時の処理系の状態によって、ワードの挙動は異なる(ように作為的にワードを定義できる)。

FORTH 処理系はデフォルトではインタプリタとして動作しており、
この段階では解釈時意味論だけ考慮していれば問題ない。

@<list>{arith}の説明に戻るが、インタプリタの挙動は以下のようになる。

 1. @<code>{6 3 4} まで解釈した直後には、スタックにはそのまま底から @<code>{6}, @<code>{3}, @<code>{4} が積まれている。
 2. @<code>{+} を読み込んだインタプリタは、ワード名とその定義を紐付けて保存している「辞書(dictionary)@<fn>{dictionary}」からその定義を見つけ出し、呼び出す。@<hidx>{+}@<code>{+} ワードはスタックの一番上に積まれている 2 つの数 @<code>{3}, @<code>{4} をポップし、和 @<code>{7} をプッシュする。
 3. @<code>{*} を読み込んだインタプリタは同様に定義を見つけ出して呼び出す。@<hidx>{* (アスタリスク)}@<code>{*} ワードはスタックの一番上に積まれている 2 つの数 @<code>{6}, @<code>{7} をポップし、積 @<code>{42} をプッシュする。
 4. @<code>{.} ワードの解釈時意味論は「スタックの一番上の要素をポップして出力すること」であるから、スタックは空になり、 @<code>{42} が出力される。

//footnote[dictionary][辞書は、実際には「ワードの定義が書き込まれたメモリ領域の先頭番地」を保存していくものだ。]

つまり、@<list>{arith} は @<m>{(3 + 4) × 6} を評価させて、結果を出力させるプログラムだったわけだ。
FORTH において算術式の評価を表現すると、自然に「被演算子を先に並べて、最後に演算子を書く記法」になる。
この記法は一般的には@<hidx>{逆ポーランド記法}@<b>{逆ポーランド記法}と呼ばれており、スタックとの相性が良い。

今後は、特に指定のない限り、Gforth を起動した直後の状態を想定してサンプルコードを
扱っていく。@<hidx>{BYE}@<code>{BYE} ワードを呼び出せば Gforth を終了できる。

スタックの要素数と各要素の値を出力する @<hidx>{.S}@<code>{.S} ワードと、改行コードを出力する @<hidx>{CR}@<code>{CR} ワードも使用して、 @<list>{arith} でのスタックの変化を探ってみよう。(@<list>{watch-stack})

//list[watch-stack][スタックの変化を探る][forth]{
CR .S 6 3 4 CR .S + CR .S * CR .S
//}

結果は @<list>{watch-stack-out} のようになるはずだ。スタック上で正しく計算されていることがわかる。

//list[watch-stack-out][実行結果]{
<0>
<3> 6 3 4
<2> 6 7
<1> 42
//}

== 基本的な算術

@<code>{+} ワードや @<code>{*} ワードと同様に、
以下のワードを用いて基本的な算術を行う。

 : @<idx>{- (マイナス)}
    減算
 : @<idx>{/ (スラッシュ)}
    除算
 : @<idx>{MOD}
    剰余
 : @<idx>{/MOD}
    「剰余」「商」を順にプッシュする
 : @<idx>{NEGATE}
    符号を反転する

//list[basic-arith][]{
23 8 - 3 / .
7 4 MOD .
7 4 /MOD .S
2 NEGATE .
//}

== スタック操作ワード

FORTH にはスタックの内容を操作するための組み込みワードが用意されている。
その 1 つが @<hidx>{DUP}@<code>{DUP} @<fn>{dup} ワードだ。
スタックの一番上に積まれている要素を複製する。

//footnote[dup][アルファベットの大文字小文字の区別はないため、dup と入力しても構わない。]

//list[dup-word][DUP ワードの利用][forth]{
8 DUP * .
//}

@<list>{dup-word}を実行すると、すぐ右側に @<code>{ 64 ok 0} と表示される。
@<hidx>{. (ドット)}@<code>{.}(ドット)ワードを呼び出すと、スタックの一番上の要素をポップして出力する。
つまり @<code>{DUP} ワードによって複製が行われスタックにはふたつの 8 が残り、
それらは @<code>{*} ワードによってポップされ 2 数の積 @<code>{64} が残る。

他にもいろいろなスタック操作用のワードが用意されている。

 : @<idx>{DROP}
    一番上の要素を破棄する。
 : @<idx>{NIP}
    一番上から 2 つ目の要素を破棄する。
 : @<idx>{SWAP}
    一番上の 2 つの要素の順序を入れ替える。
 : @<idx>{OVER}
    一番上から 2 つ目の要素をコピーして、それをプッシュする。
 : @<idx>{ROT}
    一番上から 3 つの要素を逆順にする。

スタック上の 2 つの要素をまとめて操作するためのワードも用意されている。

 : @<idx>{2DROP}
    一番上から 2 つの要素を破棄する。
 : @<idx>{2SWAP}
    スタック上の(底の方から) @<code>{a b c d} を、 @<code>{c d a b} に並び替える。
 : @<idx>{2OVER}
    スタック上の @<code>{a b c d} のうち @<code>{a b} をコピーしてプッシュする。
    プッシュ操作が完了すると @<code>{a b c d a b} のようになっている。
 : @<idx>{2DUP}
    一番上から 2 つの要素をコピーして、同じ順でプッシュする。

@<code>{2SWAP} ワードと @<code>{2OVER} ワードの説明では、スタック上の要素に識別名をつけた上で、
呼び出しの前後でそれがどう変化するかを示している。
こういった記法については、後の@<hd>{C-intro|スタック表記法}でより厳密に定義して使っていくことにする。

== コメント

//list[comments][コメントの書き方][forth]{
\ コメント
( コメント )
//}

上のような書き方をすれば、@<code>{コメント}の部分は無視される。
@<code>{\\} と @<code>{(} はそれぞれひとつのワードとして独立に定義されており、
これらを呼び出すために、後ろに空白文字が必要になる。
@<code>{\\} ワードは、後続するソースコードを行末まで読み飛ばす。
@<code>{(} ワードは、後続するソースコードを @<code>{)} まで読み飛ばす。
この 2 つのワードのように、後ろに続いているソースコードをパースして引数に取ることが可能なワードも存在している。
後述するが、そのようなワードをユーザが定義することも可能である。

== セル

FORTH で扱われるデータのサイズの最小単位は@<hidx>{セル}@<b>{セル} (cell) である。
スタックに積まれる要素のサイズもすべて 1 セルとなっている。
1 セルあたりの実際のサイズは処理系依存だが、
標準仕様に含まれている @<hidx>{CELLS}@<code>{CELLS} ワードを用いて、
使用中の処理系でのサイズを知ることができる。

//list[cells][1 セルあたりのバイト数を調べる][forth]{
1 CELLS .
//}

@<code>{CELLS} ワードは、スタックに積まれている整数値 1 つをポップし、
それに 1 セルあたりのバイト数を掛けてプッシュする。
Gforth では 1 セル @<m>{=} 8 バイトなので、@<list>{cells}を実行すると 8 と出力されるはずだ。

== スタック表記法

ワードを呼び出した際のスタックへの影響を記述するための記法を紹介する。
これは、 FORTH のリファレンス等でワードの挙動を説明する際に多用される。
基本的には、以下のようなフォーマットになっている。

//list[stack-notation][スタック表記法]{
( before -- after )
//}

@<code>{before}, @<code>{after} の部分には、スペース区切りで@<hidx>{シンボル}@<b>{シンボル}が 0 個以上並ぶ。
シンボルは、FORTH におけるデータ型や、その値のサイズを表現するための記号である。
Forth 2012 Standard において用いられているシンボルについて、@<table>{symbols}にまとめておく。
現段階では扱っていない言語機能に関するシンボルも含まれているが、今後参照する資料として一旦読み流しておいてほしい。

//table[symbols][スタック表記法で用いられるシンボル]{
シンボル	データ型	サイズ
-------------------------------
@<hidx>{flag}@<code>{flag}	フラグ	1 セル
@<hidx>{char}@<code>{char}	文字	1 セル
@<hidx>{n}@<code>{n}	符号付き整数	1 セル
@<hidx>{u}@<code>{u}	符号無し整数	1 セル
@<hidx>{x}@<code>{x}	指定のない 1 セル分のデータ	1 セル
@<hidx>{xt}@<code>{xt}	エグゼキューショントークン	1 セル
@<hidx>{addr}@<code>{addr}	アドレス	1 セル
@<hidx>{a-addr}@<code>{a-addr}	アラインメントされた領域のアドレス	1 セル
@<hidx>{c-addr}@<code>{c-addr}	文字用にアライメントされた領域のアドレス	1 セル
@<hidx>{d}@<code>{d}	2 セル符号付き整数	2 セル
@<hidx>{ud}@<code>{ud}	2 セル符号無し整数	2 セル
@<hidx>{colon-sys}@<code>{colon-sys}	定義コンパイル	処理系依存
@<hidx>{do-sys}@<code>{do-sys}	DO-LOOP 構造	処理系依存
@<hidx>{case-sys}@<code>{case-sys}	CASE 構造	処理系依存
@<hidx>{of-sys}@<code>{of-sys}	OF 構造	処理系依存
@<hidx>{orig}@<code>{orig}	コントロールフロー原点	処理系依存
@<hidx>{dest}@<code>{dest}	コントロールフロー方向	処理系依存
@<hidx>{loop-sys}@<code>{loop-sys}	ループコントロール引数	処理系依存
@<hidx>{nest-sys}@<code>{nest-sys}	定義セル	処理系依存
@<code>{i * x, j * x, k * x}	任意	0 セル以上
//}

== ワード定義の基本

ユーザがワード定義する、つまり辞書に新たな項目を追加する方法を紹介する。
基本的には、@<hidx>{: (コロン)}@<code>{:} ワードを使用する。

//list[word-def][ワード定義][forth]{
: square ( n -- n ) DUP * ;
//}

@<list>{word-def} では、新たに @<code>{square} というワードを定義している。
@<code>{( n -- n )} の部分はコメントとして扱われ、プログラマに対して
@<code>{square} ワードの挙動をスタック表記法で示す「ドキュメント」としての役割を担っている。

//list[word-interp][square ワードの利用][forth]{
8 square .
//}

@<code>{square} ワードの解釈時意味論は「スタックの一番上の要素を複製し、上 2 つの要素を掛け合わせること」となるため、
実際に @<code>{square} ワードを呼び出す @<list>{word-interp} を実行すると @<code>{64} が出力される。

@<code>{:} ワードは、呼び出されるとまず後続するソースコードを空白文字の直前まで読み込む。
それを名前として保存した後、処理系を@<hidx>{コンパイル状態}@<b>{コンパイル状態} (compilation state) に移行させる。
コンパイル状態のときにワードを認識すると、先述した解釈時意味論ではなく
@<hidx>{コンパイル時意味論}@<b>{コンパイル時意味論} (compilation semantics) に従って呼び出しが発生する。

一部のワードを除いて、多くのワードのコンパイル時意味論は「自らの解釈時意味論を定義に追加すること」である。
「処理系がインタプリタとして動作しているとき」の意味論と、
「自らの呼び出しを定義に含む別のワードが呼び出されているとき」の意味論が異なっている場合、
後者を@<hidx>{走行時意味論}@<b>{走行時意味論} (runtime semantics) と呼んで解釈時意味論と区別することがある。

== ソースファイルの利用

== Gforth パイプ

== まとめ

== 練習問題

 1. @<m>{6 - 7 × 8 + 9} を Gforth 上で計算せよ。
 2. @<code>{2SWAP} ワードのスタック表記を示せ。
 3. スタック上の @<m>{x, y} をポップし、@<m>{y × 2 + x} をプッシュするワード @<code>{word2-3} を定義せよ。
 4. スタック上の @<m>{x, y} をポップし、@<m>{x \mod 3 - y / 4} をプッシュするワード @<code>{word2-4} を定義せよ。
 5. @<code>{NIP} ワードと同じ挙動のワード @<code>{word2-5} を定義せよ。ただし、定義に「 @<code>{NIP} ワードの呼び出し」を含めてはいけない。

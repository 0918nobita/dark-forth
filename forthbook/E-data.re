= データ・辞書

ここまではスタック上のデータの操作や制御構造について触れてきたが、
この章では「データを保存する手段」や「呼び出し時の挙動を追加する手段」に関して解説していく。

== 辞書

辞書は「すでに定義されたワードのデータとコードの置き場所」である。
実際には辞書はメモリ中にロードされており、FORTH インタプリタ・コンパイラに関わるコアなワードの定義も含めて、
そこに書き込まれている。辞書に名前とコードを対にして登録すれば、当然それ以降は名前をワードとして扱える。
辞書は、定数や変数を管理するグローバル環境としても利用される。

ここからは、実際に定数や変数、ワードを辞書に書き込ませて辞書の内容の変化を追いながら、
辞書の扱い方や意義について探っていくことにしよう。

=== 定数

FORTH において定数は、@<b>{呼び出されると値を積むワード}として表現される。
そのようなワードを定義するには、@<code>{CONSTANT ( x -- )} ワードを用いる。
先に初期値をスタックに積んでおいて、直後のソースコード中に定数名を記述する。
@<code>{CONSTANT} ワードには、後ろの１単語を切り出すパーサとしての挙動もあわせて定義されている。

//list[const][定数定義][forth]{
100 CONSTANT foo
foo 2 * .
//}

//emlist[実行結果]{
200
//}

=== 変数

FORTH において変数は、@<b>{呼び出されるとスタックに参照先アドレスを積むワード}として表現される。
そのようなワードを定義するには、@<code>{VALUE ( x -- )} ワードを用いる。
@<code>{CONSTANT} ワードと同様に、スタックのトップの要素を初期値、
直後のソースコード中の１単語を変数名として変数を宣言・初期化する。
「スタックのトップの要素をアドレスとしてポップして、
書き込まれている値をプッシュする」@<code>{@ ( a-addr -- x )} ワードを通じて、
代入されている値を取得できる。

@<list>{variable} では、@<code>{270} を初期値として変数 @<code>{bar} を宣言・初期化している。
代入には @<code>{!( x a-addr -- )} ワードを用いる。
@<code>{!} ワードは、@<code>{a-addr} で指定したメモリ番地に @<code>{x} で指定した値を書き込む。

//list[variable][VALUE ワードによる変数宣言と初期化][forth]{
270 VALUE bar
bar @ .   \ 変数 bar の値を出力
42 bar !  \ 変数 bar に 42 を代入
bar @ .
//}

//emlist[実行結果]{
270 42
//}

変数の宣言だけをして、初期化を後回しにするには @<code>{VARIABLE} ワードを用いる。
@<code>{VALUE} ワードと異なるのは、先にスタックに初期値を積んでおく必要がない点だ。

//list[variable2][][forth]{
VARIABLE baz
80 baz !
baz @ .
//}

=== CREATE と辞書書き込み

@<code>{CONSTANT}, @<code>{VARIABLE}, @<code>{VALUE} ワードとは異なる、
単に「未使用のメモリ空間の先頭アドレスを返すワードを定義する」だけの低レベルな機能も提供されている。
その機能を提供するのが @<hidx>{CREATE}@<code>{CREATE} ワードだ。
@<code>{CREATE} ワードは、後続する１単語をパースして、
その名前で実行時意味論が「@<code>{CREATE} の呼び出し時点での空きデータ域の先頭アドレスを返す」のワードを定義する。
実用上は、未使用のメモリ空間の先頭から、指定した容量を確保する @<code>{ALLOT} ワードと併用される。

空きデータ域の先頭アドレスを取得するだけであれば @<code>{HERE} ワードで呼び出せば可能であるから、
@<list>{check-here} では実際に @<code>{CREATE} された名前に対する値と、
@<code>{HERE} ワードの返す値が等しいことを確かめている。

//list[check-here][CREATE ワードによって定義されるワードの動作確認][forth]{
CREATE foo
foo . CR
HERE .
//}

@<code>{CREATE} ワードの定義したワードが返すアドレスに対して、参照先の値を更新するには、
先述した @<code>{!} ワードを用いる方法と、新たに登場する @<code>{,} ワードを用いる方法がある。
@<list>{write-dict} では、後者の方法で参照先の値を更新している。

//list[write-dict][][forth]{
CREATE foo
74 ,
foo @ .
//}

//emlist[実行結果]{
74
//}

@<code>{, ( x -- )} ワードは、空きデータ域の先頭部分に @<code>{x} で指定した 1 セル分のデータを書き込み、
@<code>{HERE} ワードの返す値を 1 セル分増加させる。
つまり @<code>{x} の書き込み先は @<code>{,} ワードを呼び出すたびにズレていくため、
2 回以上参照先の値を更新するために使うことはできない。

=== 配列の表現

FORTH において、配列は「要素の値が連続して書き込まれたメモリ領域の先頭アドレス」として表現される。
要素数をメモリ上に保持する機構は備わってない。
@<list>{array} では要素が３つの配列 @<code>{array} を定義して値を書き込んでいる。

//list[array][配列の生成と要素の取得][forth]{
CREATE array 3 CELLS ALLOT

1 array !
2 array 1 CELLS + !
3 array 2 CELLS + !

array 3 CELLS DUMP

array @
array 1 CELLS + @
array 2 CELLS + @
* * .
//}

//emlist[実行結果]{
6FFFF87DDD8: 01 00 00 00  00 00 00 00 - 02 00 00 00  00 00 00 00
6FFFF87DDE8: 03 00 00 00  00 00 00 00 -
6
//}

== 匿名ワードと XT

=== XT と間接的呼び出し

定義済みのワードをデータとして扱い、
識別するためのフォーマットが @<hidx>{XT}@<b>{XT} (eXecution Token) だ。
@<code>{'} (ティック) ワードを用いて既定義ワードの XT を取得できる。
XT をもとに実際に呼び出しを発生させるには @<hidx>{EXECUTE}@<code>{EXECUTE} ワードを用いる。

//list[xt][XT の取得と間接的な呼び出し][forth]{
: hello  ( -- )  ." HELLO!" ;

' hello EXECUTE
//}

//emlist[実行結果]{
HELLO!
//}

@<code>{'} ワードの実行時意味論は
「後続するソースコードから１単語をパースして、その名前がついたワードの XT をプッシュすること」であるから、
@<list>{ntimes} のような高等的なワードを定義することが可能である。

//list[ntimes][間接的な呼び出しを複数回発生させる][forth]{
: hello ." HELLO!" ;

: 2times  ( xt -- i * x )
  DUP EXECUTE EXECUTE
;

: ntimes  ( xt n -- i * x )
  0 ?DO DUP EXECUTE LOOP DROP
;

' hello 2times CR
' hello 4 ntimes
//}

//emlist[実行結果]{
HELLO!HELLO!
HELLO!HELLO!HELLO!HELLO!
//}

=== 匿名ワード

@<list>{ntimes} では動作確認のためだけに @<code>{hello} ワードを定義したが、
実用上「その場で名前のない (というより名付ける必要のない) ワードを定義して XT だけを得る」という操作が必要になることが多い。

こういった要望に応える言語機能として@<hidx>{匿名ワード}@<b>{匿名ワード}という機能が用意されている。
その名の通り「名前のない」ワードを生成できる機能だ。
実際に匿名ワードを生成するには @<code>{:NONAME} ワードを用いる。@<code>{:NONAME} の後ろに、@<code>{:} と
同じようにワード定義の本体を記述して @<code>{;} で定義を終了する。すると @<code>{:NONAME} は XT をプッシュするので、
それをどこかに保持しておけば、いつでも @<code>{EXECUTE} できる。

@<code>{:NONAME} ワードを用いると、@<code>{ntimes} の最後の２行は @<list>{noname} のように書き換えられる。

//list[noname][:NONAME ワードの利用][forth]{
:NONAME ." HELLO!" 2times CR
:NONAME ." HELLO!" 4 ntimes
//}

=== 名前の仮取得と XT の割り当て

これでワードの定義内容をデータとして持ち回る方法を得たわけだが、
定義内容のない名前を辞書に先に登録しておく操作も可能である。
その操作には @<hidx>{DEFER}@<code>{DEFER} ワードを用いる。

定義内容の定まっていない「名前だけ先に辞書登録した項目」に対して、
定義内容としての XT を紐付けるには @<hidx>{IS}@<code>{IS} ワードを用いる。

//list[defer-is][名前の仮取得と XT 割り当て][forth]{
DEFER will-be-defined
:NONAME ." It works!" IS will-be-defined
will-be-defined
//}

//emlist[実行結果]{
It works!
//}

@<code>{DEFER} ワードで名前だけを登録したが、@<list>{defer-error} のように、
まだ定義内容を紐付けていないワードを呼び出そうとするとどうなるのだろうか。

//list[defer-error][定義内容のないワードを呼び出す実験][forth]{
DEFER foo
foo
//}

実行すると、@<code>{deferred word int-execute is uninitialized} というエラーが発生する。

== DOES>

ここまでは定数・変数を用意したり、確保したメモリ領域の先頭アドレスと名前を紐付けて辞書に登録する方法を紹介してきた。
これらは「データを保存する手段」であり、これらの操作によって生成されるワードは「保存されているデータを取得する」ためのものだ。

ただ、複雑なデータ構造をメモリ上に構築して管理する場合などを考慮すると、実用上は単に保存されているデータを返すだけでは不便だ。
保存されているデータに手を加えた上で返すようなワードを定義できたほうが便利である。

それを可能にする 1 つの方法として、ここでは @<code>{DOES>} ワードを紹介する。

@<code>{DOES>} ワードは、直前に辞書に追加された項目の実行時意味論を上書きする。
かなり難解なワードなので、まずは @<list>{does} を通して基本的な動作を確認してほしい。

//list[does][DOES> ワードの基本][forth]{
CREATE foo 57 ,

foo @ . CR  \ 参照先に 57 が書き込まれていることを確認

DOES>  \ コンパイル状態に移行
@      \ 「参照先の値を取得する」実行時意味論を追加
;      \ コンパイル状態からインタプリタに移行する

foo .  \ foo ワードの挙動が変わっているか確認
//}

//emlist[実行結果]{
57
57
//}

注目すべきは @<code>{DOES>} から @<code>{;} の部分だ。
@<code>{DOES>} ワードは最初に、処理系をコンパイル状態に移行させる。
その後 @<code>{;} によってコンパイル状態からインタプリタに移行するまで、
上書きしたい実行時意味論を記述していく。

@<list>{does} では、@<code>{foo} ワードが @<code>{DOES>} ～ @<code>{;} の前後で
「参照先のアドレス」ではなく「参照先の値」を返すように変化している。

@<code>{DOES>} ワードを用いて上書きする実行時意味論では、
たとえ @<code>{DOES>} ～ @<code>{;} の間に何も記述しなくても、
最初に「参照先のアドレスをプッシュする」という意味論が追加される。
つまり @<code>{DOES>} ～ @<code>{;} の間では、最初に参照先アドレスがプッシュされるという前提のもとで
呼び出し時の処理を記述していくことになる。@<list>{does} でも、
「参照先の値を取得して返す」という実行時意味論で上書きするために @<code>{DOES>} と @<code>{;} の間で
(先に参照先アドレスがプッシュされているという前提のもとで) @<code>{@} ワードを記述している。

@<code>{DOES>} ワードの活用法のひとつとして、「配列の要素を取り出しやすくする」方法を紹介する。

//list[does-advanced][配列を、添字を指定して要素を取得するワードとして再定義する][forth]{
: nth  DOES> SWAP CELLS + @ ;

CREATE array 3 CELLS ALLOT
1 array !
2 array 1 CELLS + !
3 array 2 CELLS + !

nth

0 array .
1 array .
2 array .
//}

//emlist[実行結果]{
1 2 3
//}

@<code>{CREATE array 3 CELLS ALLOT} を実行した時点では、
@<code>{array} ワードは単に参照先アドレスを返すワードだ。
スタック表記は @<code>{( -- a-addr )} のようになる。
だが @<code>{nth} ワードを呼び出すと @<code>{array} ワードの実行時意味論は変わる。
先に添字 (0 始まり) をデータスタックに積んでおくと、
それによって指定される要素の値を取得して返すワードになる。
スタック表記は @<code>{( n -- x )} のようになる。
